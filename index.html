<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Let Me Google That For You: Barry Stanchio</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            background-color: #fff;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100%;
            padding-top: 120px;
            width: 100%;
        }
        
        .logo {
            margin-bottom: 30px;
            text-align: center;
        }
        
        .logo img {
            max-width: 272px;
            width: 100%;
            height: auto;
        }
        
        .search-container {
            position: relative;
            max-width: 584px;
            width: 90%;
            margin: 0 auto 30px auto;
        }
        
        .search-box {
            width: 100%;
            height: 46px;
            border: 1px solid #dfe1e5;
            border-radius: 24px;
            padding: 0 20px;
            font-size: 16px;
            outline: none;
            box-shadow: 0 1px 3px rgba(32, 33, 36, 0.1);
        }
        
        .search-box:hover, .search-box:focus {
            box-shadow: 0 1px 6px rgba(32, 33, 36, 0.28);
            border-color: rgba(223, 225, 229, 0);
        }
        
        .search-buttons {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .search-button {
            background-color: #f8f9fa;
            border: 1px solid #f8f9fa;
            border-radius: 4px;
            color: #3c4043;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin: 11px 4px;
            padding: 0 16px;
            height: 36px;
            cursor: pointer;
        }
        
        .search-button:hover {
            box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
            border: 1px solid #dadce0;
        }
        
        .results-page {
            display: none;
            width: 100%;
        }
        
        .search-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            border-bottom: 1px solid #ebebeb;
            position: sticky;
            top: 0;
            background-color: white;
            width: 100%;
        }
        
        .header-content {
            display: flex;
            align-items: center;
            width: 100%;
            max-width: 768px;
        }
        
        .header-logo {
            height: 30px;
            width: auto;
            margin-right: 20px;
        }
        
        .header-search-container {
            flex-grow: 1;
            max-width: 584px;
        }
        
        .header-search {
            width: 100%;
            height: 44px;
            border: 1px solid #dfe1e5;
            border-radius: 24px;
            padding: 0 20px;
            font-size: 16px;
            outline: none;
            box-shadow: 0 1px 3px rgba(32, 33, 36, 0.1);
        }
        
        .search-results {
            max-width: 650px;
            margin: 0 auto;
            padding: 15px;
            width: 100%;
        }
        
        .result {
            margin-bottom: 30px;
        }
        
        .result-url {
            color: #202124;
            font-size: 14px;
            margin-bottom: 5px;
            word-break: break-word;
        }
        
        .result-title {
            color: #1a0dab;
            font-size: 20px;
            font-weight: normal;
            margin: 0;
            margin-bottom: 5px;
            cursor: pointer;
        }
        
        .result-title:hover {
            text-decoration: underline;
        }
        
        .result-description {
            color: #4d5156;
            font-size: 14px;
            line-height: 1.58;
        }
        
        /* Blinking cursor styling */
        .blink-cursor {
            display: inline-block;
            width: 2px;
            height: 24px;
            background-color: black;
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: middle;
        }
        
        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }
        
        .loading-text {
            text-align: center;
            margin-top: 20px;
            font-size: 16px;
            display: none;
        }
        
        a {
            text-decoration: none;
        }
        
        @keyframes buttonAnimation {
            0% { background-color: #f8f9fa; }
            70% { background-color: #f8f9fa; }
            80% { background-color: #e6e6e6; }
            90% { background-color: #f8f9fa; }
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding-top: 80px;
            }
            
            .logo img {
                max-width: 180px;
            }
            
            .header-content {
                flex-direction: column;
                align-items: center;
            }
            
            .header-logo {
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .header-search-container {
                width: 90%;
            }
            
            .search-box, .header-search {
                font-size: 14px;
            }
        }
        
        /* Tetris Game Styles */
        #tetris-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            overflow: hidden;
        }
        
        #tetris-wrapper {
            position: relative;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #tetris-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: white;
            font-size: 18px;
        }
        
        #tetris-canvas {
            border: 2px solid white;
            background-color: #111;
        }
        
        #tetris-sidebar {
            display: flex;
            flex-direction: column;
            margin-left: 20px;
            color: white;
        }
        
        #tetris-next-piece-container {
            border: 2px solid white;
            width: 100px;
            height: 100px;
            margin: 10px 0;
            background-color: #111;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #tetris-score, #tetris-level, #tetris-lines {
            margin: 10px 0;
        }
        
        #tetris-controls {
            color: white;
            margin-top: 20px;
            font-size: 14px;
            text-align: center;
        }
        
        #tetris-mobile-controls {
            display: none;
            width: 100%;
            max-width: 300px;
            margin-top: 20px;
        }
        
        .tetris-mobile-button {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 24px;
            touch-action: manipulation;
        }
        
        .tetris-mobile-row {
            display: flex;
            justify-content: center;
            margin: 5px 0;
        }
        
        #tetris-close-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.3);
            border: none;
            color: white;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
        }
        
        #tetris-game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        
        #tetris-restart-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 15px;
            margin-top: 10px;
            cursor: pointer;
            border-radius: 5px;
        }
        
        /* Media query for mobile devices */
        @media (max-width: 768px) {
            #tetris-wrapper {
                flex-direction: column;
            }
            
            #tetris-sidebar {
                margin-left: 0;
                margin-top: 20px;
                flex-direction: row;
                justify-content: space-around;
                width: 100%;
            }
            
            #tetris-next-piece-container {
                width: 80px;
                height: 80px;
            }
            
            #tetris-mobile-controls {
                display: block;
            }
            
            #tetris-controls {
                display: none;
            }
            
            #tetris-canvas {
                width: 240px;
                height: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="search-page">
        <div class="logo">
            <img src="https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png" alt="Google Logo">
        </div>
        <div class="search-container">
            <span id="typed-text-container">
                <span id="typed-text"></span><span id="cursor" class="blink-cursor"></span>
            </span>
            <input type="text" class="search-box" id="search-box" style="opacity: 0; position: absolute;">
        </div>
        <div class="search-buttons">
            <button class="search-button" id="search-btn">Google Search</button>
            <button class="search-button">I'm Feeling Lucky</button>
        </div>
        <div class="loading-text" id="loading-text">Searching for Barry Stanchio...</div>
    </div>
    
    <div class="results-page" id="results-page">
        <div id="easter-egg" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 1000; text-align: center; padding-top: 50px; overflow: hidden;">
            <div class="animation-container" style="width: 100%; height: 60%; position: relative;">
                <!-- T-Rex Animation -->
                <div id="trex" style="position: absolute; left: -300px; top: 50%; transform: translateY(-50%); width: 300px; height: 180px;">
                    <svg width="300" height="180" viewBox="0 0 300 180">
                        <g id="trex-body">
                            <path d="M50,80 L120,80 L150,50 L190,50 L200,60 L200,90 L220,100 L220,120 L200,130 L180,130 L170,120 L150,120 L140,130 L130,130 L120,120 L110,120 L100,130 L60,130 L50,120 L40,120 L30,130 L20,130 L10,120 L10,100 L30,90 L30,90 L40,80" fill="#4CAF50" />
                            <circle cx="170" cy="70" r="10" fill="white" />
                            <circle cx="173" cy="70" r="5" fill="black" />
                            <path d="M190,90 L220,90 L220,100 L190,100 Z" fill="white" /> <!-- Teeth -->
                            <path d="M30,130 L20,150 L30,170 L40,150 L30,130" fill="#4CAF50" /> <!-- Left Leg -->
                            <path d="M100,130 L90,150 L100,170 L110,150 L100,130" fill="#4CAF50" /> <!-- Right Leg -->
                        </g>
                    </svg>
                </div>
                
                <!-- Stick Figure Barry -->
                <div id="barry" style="position: absolute; right: -100px; top: 50%; transform: translateY(-50%); width: 100px; height: 120px;">
                    <svg width="100" height="120" viewBox="0 0 100 120">
                        <g id="stick-figure">
                            <circle cx="50" cy="20" r="15" fill="#FFF" />
                            <line x1="50" y1="35" x2="50" y2="80" stroke="#FFF" stroke-width="4" />
                            <line x1="50" y1="50" x2="20" y2="60" stroke="#FFF" stroke-width="4" />
                            <line x1="50" y1="50" x2="80" y2="60" stroke="#FFF" stroke-width="4" />
                            <line x1="50" y1="80" x2="30" y2="110" stroke="#FFF" stroke-width="4" />
                            <line x1="50" y1="80" x2="70" y2="110" stroke="#FFF" stroke-width="4" />
                        </g>
                    </svg>
                </div>
                
                <!-- Blood Splatter Effect (hidden initially) -->
                <div id="blood-splatter" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: none;">
                    <svg width="200" height="200" viewBox="0 0 200 200">
                        <circle cx="100" cy="100" r="5" fill="#FF0000" />
                        <circle cx="110" cy="90" r="8" fill="#FF0000" />
                        <circle cx="90" cy="110" r="10" fill="#FF0000" />
                        <circle cx="120" cy="100" r="7" fill="#FF0000" />
                        <circle cx="100" cy="120" r="9" fill="#FF0000" />
                        <circle cx="80" cy="100" r="6" fill="#FF0000" />
                        <circle cx="100" cy="80" r="8" fill="#FF0000" />
                    </svg>
                </div>
            </div>
            
            <!-- Message Text with Animation -->
            <div id="message-text" style="font-family: 'Impact', sans-serif; font-size: 48px; color: #FF0000; margin-top: 20px; opacity: 0; transform: scale(0.5); transition: all 1s ease;">BARRY STANCHIO SUCKS!</div>
            
            <button id="close-easter-egg" style="margin-top: 30px; padding: 10px 20px; background-color: #F44336; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer;">CLOSE</button>
        </div>
        
        <!-- Tetris Game Container -->
        <div id="tetris-container">
            <div id="tetris-wrapper">
                <div id="tetris-header">
                    <div>TETRIS</div>
                    <div>BARRY'S TETRIS</div>
                </div>
                <div style="display: flex; flex-direction: row; align-items: flex-start;">
                    <canvas id="tetris-canvas" width="300" height="600"></canvas>
                    <div id="tetris-sidebar">
                        <div>NEXT:</div>
                        <div id="tetris-next-piece-container">
                            <canvas id="tetris-next-piece" width="80" height="80"></canvas>
                        </div>
                        <div id="tetris-score">SCORE: 0</div>
                        <div id="tetris-level">LEVEL: 1</div>
                        <div id="tetris-lines">LINES: 0</div>
                    </div>
                </div>
                <div id="tetris-controls">
                    CONTROLS:<br>
                    ← → : Move<br>
                    ↑ : Rotate<br>
                    ↓ : Soft Drop<br>
                    SPACE : Hard Drop<br>
                    P : Pause
                </div>
                <div id="tetris-mobile-controls">
                    <div class="tetris-mobile-row">
                        <div class="tetris-mobile-button" id="tetris-rotate">↑</div>
                    </div>
                    <div class="tetris-mobile-row">
                        <div class="tetris-mobile-button" id="tetris-left">←</div>
                        <div class="tetris-mobile-button" id="tetris-down">↓</div>
                        <div class="tetris-mobile-button" id="tetris-right">→</div>
                    </div>
                    <div class="tetris-mobile-row">
                        <div class="tetris-mobile-button" id="tetris-drop">⬇⬇</div>
                    </div>
                </div>
                <div id="tetris-game-over">
                    <h2>GAME OVER</h2>
                    <p id="tetris-final-score">Score: 0</p>
                    <button id="tetris-restart-button">Play Again</button>
                </div>
            </div>
            <button id="tetris-close-button">CLOSE</button>
        </div>
        
        <div class="search-header">
            <div class="header-content">
                <img src="https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_272x92dp.png" alt="Google Logo" class="header-logo">
                <div class="header-search-container">
                    <input type="text" class="header-search" id="results-search-box" value="Barry Stanchio">
                </div>
            </div>
        </div>
        
        <div class="search-results">
            <p>About 14,700 results (0.62 seconds)</p>
            
            <div class="result">
                <div class="result-url">https://trellis.law/doc/25550033/memorandum-law-in-support-motion-003</div>
                <h3 class="result-title">
                    <a href="https://trellis.law/doc/25550033/memorandum-law-in-support-motion-003" target="_blank">Motion for Child Support in Silvia Azucar v. Barry Stanchio</a>
                </h3>
                <div class="result-description">
                    On January 6, 2014, Silvia Azucar (herein after "Ms. Azucar" and/or "Plaintiff"), a 39-year old woman, attended Barry Stanchio's (herein after "Defendent") daughter's sweet sixteen birthday party...Defendent, forcibly and without consent, placed his hand up Ms. Azucar's dress, grabbing her in intimate area and attempting to digitally penetrate her. 
                </div>
            </div>
            
            <div class="result">
                <div class="result-url">https://trellis.law/doc/25549933/affidavit-affirmation-in-support-motion-001</div>
                <h3 class="result-title">
                    <a href="https://trellis.law/doc/25549933/affidavit-affirmation-in-support-motion-001" target="_blank">Motion-Secondary: AZUCAR, SILVIA v. STANCHIO, BARRY</a>
                </h3>
                <div class="result-description">
                    The within action was brought on behalf of Plaintiff, against Defendent BARRY STANCHIO, and involes a claim for a Battery, Assault, Intentional Infliction of Emotional Distress, and Negligent Infliction of Emotional Distress...
                </div>
            </div>
            
            <div class="result">
                <div class="result-url">https://twitter.com/barrystanchio</div>
                <h3 class="result-title">
                    <a href="https://twitter.com/barrystanchio" target="_blank">Barry Stanchio (@barrystanchio) | Twitter</a>
                </h3>
                <div class="result-description">
                    The latest Tweets from Barry Stanchio (@barrystanchio). Official Twitter account. Follow for updates on projects and events.
                </div>
            </div>
            
            <div class="result">
                <div class="result-url">https://www.example.org/articles/by/barry-stanchio</div>
                <h3 class="result-title">
                    <a href="https://www.example.org/articles/by/barry-stanchio" target="_blank">Articles by Barry Stanchio - Example Publications</a>
                </h3>
                <div class="result-description">
                    Read the latest articles, research papers, and opinion pieces written by Barry Stanchio. Covering topics in his area of expertise.
                </div>
            </div>
            
            <div class="result">
                <div class="result-url">https://www.example.net/events/speakers/barry-stanchio</div>
                <h3 class="result-title">
                    <a href="https://www.example.net/events/speakers/barry-stanchio" target="_blank">Barry Stanchio - Featured Speaker | Example Conference</a>
                </h3>
                <div class="result-description">
                    Barry Stanchio will be a featured speaker at this year's conference. View his session details and speaker biography.
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const typedText = document.getElementById('typed-text');
            const cursor = document.getElementById('cursor');
            const searchBox = document.getElementById('search-box');
            const typedTextContainer = document.getElementById('typed-text-container');
            const searchBtn = document.getElementById('search-btn');
            const searchPage = document.getElementById('search-page');
            const resultsPage = document.getElementById('results-page');
            const loadingText = document.getElementById('loading-text');
            const easterEgg = document.getElementById('easter-egg');
            const closeEasterEgg = document.getElementById('close-easter-egg');
            const resultsSearchBox = document.getElementById('results-search-box');
            const trex = document.getElementById('trex');
            const barry = document.getElementById('barry');
            const bloodSplatter = document.getElementById('blood-splatter');
            const messageText = document.getElementById('message-text');
            const tetrisContainer = document.getElementById('tetris-container');
            const tetrisCloseButton = document.getElementById('tetris-close-button');
            
            // Style the typed text container to look like the search box
            typedTextContainer.style.display = 'block';
            typedTextContainer.style.width = '100%';
            typedTextContainer.style.height = '46px';
            typedTextContainer.style.border = '1px solid #dfe1e5';
            typedTextContainer.style.borderRadius = '24px';
            typedTextContainer.style.padding = '0 20px';
            typedTextContainer.style.fontSize = '16px';
            typedTextContainer.style.lineHeight = '46px';
            typedTextContainer.style.backgroundColor = 'white';
            typedTextContainer.style.boxShadow = '0 1px 3px rgba(32, 33, 36, 0.1)';
            
            // Function to close the mobile keyboard
            function closeKeyboard() {
                // Blur any active element to dismiss the keyboard
                if (document.activeElement instanceof HTMLElement) {
                    document.activeElement.blur();
                }
                
                // For iOS devices, create a temporary input to focus and blur
                const tempInput = document.createElement('input');
                tempInput.style.position = 'absolute';
                tempInput.style.opacity = '0';
                tempInput.style.height = '0';
                tempInput.style.width = '0';
                document.body.appendChild(tempInput);
                tempInput.focus();
                tempInput.blur();
                document.body.removeChild(tempInput);
                
                // For Android, we can try changing the display style temporarily
                document.documentElement.style.height = '100%';
                document.documentElement.style.overflow = 'hidden';
                setTimeout(function() {
                    document.documentElement.style.height = '';
                    document.documentElement.style.overflow = '';
                }, 100);
            }
            
            // Simpler typing animation that doesn't rely on cursor positioning
            function typeWriter(text, i) {
                if (i < text.length) {
                    typedText.textContent += text.charAt(i);
                    i++;
                    setTimeout(function() { typeWriter(text, i); }, 100);
                } else {
                    // After typing is complete, trigger button animation
                    setTimeout(function() {
                        searchBtn.style.animation = 'buttonAnimation 0.5s forwards';
                        
                        // Show loading text
                        setTimeout(function() {
                            loadingText.style.display = 'block';
                            
                            // After "searching", show results page
                            setTimeout(function() {
                                searchPage.style.display = 'none';
                                resultsPage.style.display = 'block';
                            }, 2000);
                        }, 500);
                    }, 1000);
                }
            }
            
            // Add event listener for the Enter key in the results search box
            resultsSearchBox.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    
                    // Close the keyboard first
                    closeKeyboard();
                    
                    // Check if the search query is "Tetris" (case insensitive)
                    if (resultsSearchBox.value.trim().toLowerCase() === 'tetris') {
                        // Launch Tetris game
                        tetrisContainer.style.display = 'flex';
                        startTetrisGame();
                    } else if (resultsSearchBox.value.trim().toLowerCase() === 'barry stanchio') {
                        // Show the original easter egg with a slight delay to ensure keyboard is closed
                        setTimeout(function() {
                            easterEgg.style.display = 'block';
                            
                            // Animation sequence
                            setTimeout(function() {
                                // Animate T-Rex
                                trex.style.transition = 'left 3s ease-in-out';
                                trex.style.left = '30%';
                                
                                // Animate Barry
                                barry.style.transition = 'right 2s ease-in-out';
                                barry.style.right = '40%';
                                
                                // Collision and blood splatter
                                setTimeout(function() {
                                    bloodSplatter.style.display = 'block';
                                    bloodSplatter.style.left = '45%';
                                    barry.style.display = 'none';
                                    
                                    // Show message with animation
                                    setTimeout(function() {
                                        messageText.style.opacity = '1';
                                        messageText.style.transform = 'scale(1)';
                                    }, 500);
                                }, 2000);
                            }, 500);
                        }, 100);
                    }
                }
            });
            
            // Close easter egg when button is clicked
            closeEasterEgg.addEventListener('click', function() {
                resetEasterEgg();
            });
            
            // Close tetris when button is clicked
            tetrisCloseButton.addEventListener('click', function() {
                tetrisContainer.style.display = 'none';
                // Pause the game
                if (tetrisGameState && !tetrisGameState.gameOver) {
                    tetrisGameState.isPaused = true;
                }
            });
            
            // Close easter egg when Escape key is pressed
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    if (easterEgg.style.display === 'block') {
                        resetEasterEgg();
                    }
                    if (tetrisContainer.style.display === 'flex') {
                        tetrisContainer.style.display = 'none';
                        // Pause the game
                        if (tetrisGameState && !tetrisGameState.gameOver) {
                            tetrisGameState.isPaused = true;
                        }
                    }
                }
            });
            
            // Function to reset the easter egg
            function resetEasterEgg() {
                easterEgg.style.display = 'none';
                // Reset animations
                setTimeout(function() {
                    trex.style.transition = 'none';
                    trex.style.left = '-300px';
                    barry.style.transition = 'none';
                    barry.style.right = '-100px';
                    barry.style.display = 'block';
                    bloodSplatter.style.display = 'none';
                    messageText.style.opacity = '0';
                    messageText.style.transform = 'scale(0.5)';
                }, 100);
            }
            
            // Start the animation sequence after a short delay
            setTimeout(function() {
                // Start typing after a short delay
                typeWriter("Barry Stanchio", 0);
            }, 1000);
            
            // TETRIS GAME IMPLEMENTATION
            const canvas = document.getElementById('tetris-canvas');
            const ctx = canvas.getContext('2d');
            const nextPieceCanvas = document.getElementById('tetris-next-piece');
            const nextPieceCtx = nextPieceCanvas.getContext('2d');
            const scoreElement = document.getElementById('tetris-score');
            const levelElement = document.getElementById('tetris-level');
            const linesElement = document.getElementById('tetris-lines');
            const gameOverElement = document.getElementById('tetris-game-over');
            const finalScoreElement = document.getElementById('tetris-final-score');
            const restartButton = document.getElementById('tetris-restart-button');
            
            // Mobile controls
            const mobileLeft = document.getElementById('tetris-left');
            const mobileRight = document.getElementById('tetris-right');
            const mobileDown = document.getElementById('tetris-down');
            const mobileRotate = document.getElementById('tetris-rotate');
            const mobileDrop = document.getElementById('tetris-drop');
            
            // Set up game constants
            const COLS = 10;
            const ROWS = 20;
            const BLOCK_SIZE = Math.floor(canvas.width / COLS);
            const NEXT_BLOCK_SIZE = Math.floor(nextPieceCanvas.width / 4);
            
            // Colors for tetrominos
            const COLORS = [
                null,
                '#FF0D72', // I - Red
                '#0DC2FF', // O - Blue
                '#0DFF72', // T - Green
                '#F538FF', // J - Purple
                '#FF8E0D', // L - Orange
                '#FFE138', // S - Yellow
                '#3877FF'  // Z - Deep Blue
            ];
            
            // Tetromino shapes
            const SHAPES = [
                [],
                // I
                [
                    [0, 0, 0, 0],
                    [1, 1, 1, 1],
                    [0, 0, 0, 0],
                    [0, 0, 0, 0]
                ],
                // O
                [
                    [2, 2],
                    [2, 2]
                ],
                // T
                [
                    [0, 3, 0],
                    [3, 3, 3],
                    [0, 0, 0]
                ],
                // J
                [
                    [4, 0, 0],
                    [4, 4, 4],
                    [0, 0, 0]
                ],
                // L
                [
                    [0, 0, 5],
                    [5, 5, 5],
                    [0, 0, 0]
                ],
                // S
                [
                    [0, 6, 6],
                    [6, 6, 0],
                    [0, 0, 0]
                ],
                // Z
                [
                    [7, 7, 0],
                    [0, 7, 7],
                    [0, 0, 0]
                ]
            ];
            
            // Game state
            let tetrisGameState = null;
            
            // Function to create the game state
            function createGameState() {
                return {
                    board: Array(ROWS).fill().map(() => Array(COLS).fill(0)),
                    piece: null,
                    nextPiece: null,
                    score: 0,
                    level: 1,
                    lines: 0,
                    gameOver: false,
                    isPaused: false,
                    dropCounter: 0,
                    dropInterval: 1000, // Initial speed (ms)
                    lastTime: 0
                };
            }
            
            // Function to create a random piece
            function createPiece() {
                const index = Math.floor(Math.random() * 7) + 1;
                const piece = {
                    shape: SHAPES[index],
                    color: COLORS[index],
                    pos: {
                        x: Math.floor(COLS / 2) - Math.floor(SHAPES[index][0].length / 2),
                        y: 0
                    }
                };
                return piece;
            }
            
            // Function to draw a block
            function drawBlock(ctx, x, y, color, blockSize) {
                ctx.fillStyle = color;
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize);
                
                // Add 3D effect
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(x * blockSize, y * blockSize, blockSize, blockSize / 10);
                ctx.fillRect(x * blockSize, y * blockSize, blockSize / 10, blockSize);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(x * blockSize, (y + 1) * blockSize - blockSize / 10, blockSize, blockSize / 10);
                ctx.fillRect((x + 1) * blockSize - blockSize / 10, y * blockSize, blockSize / 10, blockSize);
                
                // Draw outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.strokeRect(x * blockSize, y * blockSize, blockSize, blockSize);
            }
            
            // Function to draw the current piece
            function drawPiece(ctx, piece, blockSize) {
                if (!piece) return;
                
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            drawBlock(
                                ctx,
                                x + piece.pos.x,
                                y + piece.pos.y,
                                piece.color,
                                blockSize
                            );
                        }
                    });
                });
            }
            
            // Function to draw the next piece
            function drawNextPiece() {
                if (!tetrisGameState.nextPiece) return;
                
                // Clear the next piece canvas
                nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
                
                // Calculate offset to center the piece in the preview
                const offsetX = (nextPieceCanvas.width - tetrisGameState.nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
                const offsetY = (nextPieceCanvas.height - tetrisGameState.nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;
                
                // Draw the next piece
                tetrisGameState.nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            nextPieceCtx.fillStyle = tetrisGameState.nextPiece.color;
                            nextPieceCtx.fillRect(
                                offsetX + x * NEXT_BLOCK_SIZE,
                                offsetY + y * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE
                            );
                            
                            // Add 3D effect
                            nextPieceCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                            nextPieceCtx.fillRect(
                                offsetX + x * NEXT_BLOCK_SIZE,
                                offsetY + y * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE / 10
                            );
                            nextPieceCtx.fillRect(
                                offsetX + x * NEXT_BLOCK_SIZE,
                                offsetY + y * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE / 10,
                                NEXT_BLOCK_SIZE
                            );
                            
                            nextPieceCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                            nextPieceCtx.fillRect(
                                offsetX + x * NEXT_BLOCK_SIZE,
                                offsetY + (y + 1) * NEXT_BLOCK_SIZE - NEXT_BLOCK_SIZE / 10,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE / 10
                            );
                            nextPieceCtx.fillRect(
                                offsetX + (x + 1) * NEXT_BLOCK_SIZE - NEXT_BLOCK_SIZE / 10,
                                offsetY + y * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE / 10,
                                NEXT_BLOCK_SIZE
                            );
                            
                            // Draw outline
                            nextPieceCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                            nextPieceCtx.strokeRect(
                                offsetX + x * NEXT_BLOCK_SIZE,
                                offsetY + y * NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE,
                                NEXT_BLOCK_SIZE
                            );
                        }
                    });
                });
            }
            
            // Function to draw the game board
            function drawBoard() {
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw the board with blocks
                tetrisGameState.board.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            drawBlock(ctx, x, y, COLORS[value], BLOCK_SIZE);
                        }
                    });
                });
                
                // Draw the current piece
                drawPiece(ctx, tetrisGameState.piece, BLOCK_SIZE);
                
                // Draw grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                // Vertical lines
                for (let i = 1; i < COLS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * BLOCK_SIZE, 0);
                    ctx.lineTo(i * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let i = 1; i < ROWS; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * BLOCK_SIZE);
                    ctx.lineTo(COLS * BLOCK_SIZE, i * BLOCK_SIZE);
                    ctx.stroke();
                }
            }
            
            // Function to update the score and other UI elements
            function updateScore() {
                scoreElement.textContent = `SCORE: ${tetrisGameState.score}`;
                levelElement.textContent = `LEVEL: ${tetrisGameState.level}`;
                linesElement.textContent = `LINES: ${tetrisGameState.lines}`;
            }
            
            // Function to check for collision
            function checkCollision(piece, offsetX, offsetY, newMatrix = null) {
                const matrix = newMatrix || piece.shape;
                
                for (let y = 0; y < matrix.length; y++) {
                    for (let x = 0; x < matrix[y].length; x++) {
                        if (matrix[y][x] !== 0 && (
                            // Out of bounds check
                            piece.pos.y + y + offsetY < 0 ||
                            piece.pos.y + y + offsetY >= ROWS ||
                            piece.pos.x + x + offsetX < 0 ||
                            piece.pos.x + x + offsetX >= COLS ||
                            // Collision with another block
                            (piece.pos.y + y + offsetY >= 0 && 
                             tetrisGameState.board[piece.pos.y + y + offsetY][piece.pos.x + x + offsetX] !== 0)
                        )) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // Function to move the piece
            function movePiece(direction) {
                if (tetrisGameState.gameOver || tetrisGameState.isPaused) return;
                
                const offset = {x: 0, y: 0};
                
                if (direction === 'left') offset.x = -1;
                else if (direction === 'right') offset.x = 1;
                else if (direction === 'down') offset.y = 1;
                
                if (!checkCollision(tetrisGameState.piece, offset.x, offset.y)) {
                    tetrisGameState.piece.pos.x += offset.x;
                    tetrisGameState.piece.pos.y += offset.y;
                } else if (direction === 'down') {
                    // If we can't move down, lock the piece
                    lockPiece();
                    
                    // Check for cleared lines
                    checkLines();
                    
                    // Get the next piece
                    tetrisGameState.piece = tetrisGameState.nextPiece;
                    tetrisGameState.nextPiece = createPiece();
                    drawNextPiece();
                    
                    // Check for game over
                    if (checkCollision(tetrisGameState.piece, 0, 0)) {
                        gameOver();
                    }
                }
                
                drawBoard();
            }
            
            // Function to rotate the piece
            function rotatePiece() {
                if (tetrisGameState.gameOver || tetrisGameState.isPaused) return;
                
                // Create a rotated matrix
                const rotated = [];
                for (let i = 0; i < tetrisGameState.piece.shape[0].length; i++) {
                    const row = [];
                    for (let j = tetrisGameState.piece.shape.length - 1; j >= 0; j--) {
                        row.push(tetrisGameState.piece.shape[j][i]);
                    }
                    rotated.push(row);
                }
                
                // Check if rotation is possible
                const originalShape = tetrisGameState.piece.shape;
                tetrisGameState.piece.shape = rotated;
                
                // Wall kick checks (try to offset the piece if it's too close to a wall)
                const offsets = [0, 1, -1, 2, -2];
                let kicked = false;
                
                for (const offset of offsets) {
                    if (!checkCollision(tetrisGameState.piece, offset, 0)) {
                        tetrisGameState.piece.pos.x += offset;
                        kicked = true;
                        break;
                    }
                }
                
                // If no wall kick works, revert to the original shape
                if (!kicked) {
                    tetrisGameState.piece.shape = originalShape;
                }
                
                drawBoard();
            }
            
            // Function to perform a hard drop
            function hardDrop() {
                if (tetrisGameState.gameOver || tetrisGameState.isPaused) return;
                
                while (!checkCollision(tetrisGameState.piece, 0, 1)) {
                    tetrisGameState.piece.pos.y++;
                    tetrisGameState.score += 2; // Bonus points for hard drop
                }
                
                updateScore();
                movePiece('down'); // Lock the piece and check for cleared lines
            }
            
            // Function to lock the current piece onto the board
            function lockPiece() {
                tetrisGameState.piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            // Make sure we don't go out of bounds
                            if (tetrisGameState.piece.pos.y + y >= 0) {
                                tetrisGameState.board[tetrisGameState.piece.pos.y + y][tetrisGameState.piece.pos.x + x] = value;
                            }
                        }
                    });
                });
            }
            
            // Function to check for completed lines
            function checkLines() {
                let linesCleared = 0;
                
                for (let y = ROWS - 1; y >= 0; y--) {
                    let lineComplete = true;
                    
                    for (let x = 0; x < COLS; x++) {
                        if (tetrisGameState.board[y][x] === 0) {
                            lineComplete = false;
                            break;
                        }
                    }
                    
                    if (lineComplete) {
                        // Remove the line
                        tetrisGameState.board.splice(y, 1);
                        // Add an empty line at the top
                        tetrisGameState.board.unshift(Array(COLS).fill(0));
                        linesCleared++;
                        // Check this line again since we've moved all rows down
                        y++;
                    }
                }
                
                // Update score based on lines cleared
                if (linesCleared > 0) {
                    // Score calculation based on level and lines cleared
                    const linePoints = [0, 100, 300, 500, 800]; // Points for 0, 1, 2, 3, 4 lines
                    tetrisGameState.score += linePoints[linesCleared] * tetrisGameState.level;
                    tetrisGameState.lines += linesCleared;
                    
                    // Level up every 10 lines
                    const newLevel = Math.floor(tetrisGameState.lines / 10) + 1;
                    if (newLevel > tetrisGameState.level) {
                        tetrisGameState.level = newLevel;
                        // Increase speed with each level
                        tetrisGameState.dropInterval = Math.max(100, 1000 - (tetrisGameState.level - 1) * 100);
                    }
                    
                    updateScore();
                }
            }
            
            // Function to handle game over
            function gameOver() {
                tetrisGameState.gameOver = true;
                gameOverElement.style.display = 'block';
                finalScoreElement.textContent = `Score: ${tetrisGameState.score}`;
            }
            
            // Function to restart the game
            function restartGame() {
                tetrisGameState = createGameState();
                tetrisGameState.piece = createPiece();
                tetrisGameState.nextPiece = createPiece();
                gameOverElement.style.display = 'none';
                updateScore();
                drawNextPiece();
                drawBoard();
                // Resume the game loop
                requestAnimationFrame(gameLoop);
            }
            
            // Main game loop
            function gameLoop(time = 0) {
                if (!tetrisGameState) return;
                
                const deltaTime = time - tetrisGameState.lastTime;
                tetrisGameState.lastTime = time;
                
                if (!tetrisGameState.gameOver && !tetrisGameState.isPaused) {
                    tetrisGameState.dropCounter += deltaTime;
                    
                    if (tetrisGameState.dropCounter > tetrisGameState.dropInterval) {
                        movePiece('down');
                        tetrisGameState.dropCounter = 0;
                    }
                }
                
                requestAnimationFrame(gameLoop);
            }
            
            // Start the Tetris game
            function startTetrisGame() {
                // Create a new game state
                tetrisGameState = createGameState();
                tetrisGameState.piece = createPiece();
                tetrisGameState.nextPiece = createPiece();
                
                // Update the UI
                updateScore();
                drawNextPiece();
                drawBoard();
                
                // Start the game loop
                requestAnimationFrame(gameLoop);
            }
            
            // Event listeners for keyboard controls
            document.addEventListener('keydown', (event) => {
                if (tetrisContainer.style.display !== 'flex') return;
                
                if (event.key === 'ArrowLeft') {
                    movePiece('left');
                } else if (event.key === 'ArrowRight') {
                    movePiece('right');
                } else if (event.key === 'ArrowDown') {
                    movePiece('down');
                } else if (event.key === 'ArrowUp') {
                    rotatePiece();
                } else if (event.key === ' ') {
                    hardDrop();
                } else if (event.key === 'p' || event.key === 'P') {
                    // Toggle pause
                    if (tetrisGameState && !tetrisGameState.gameOver) {
                        tetrisGameState.isPaused = !tetrisGameState.isPaused;
                    }
                }
            });
            
            // Event listeners for mobile controls
            mobileLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movePiece('left');
            });
            
            mobileRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movePiece('right');
            });
            
            mobileDown.addEventListener('touchstart', (e) => {
                e.preventDefault();
                movePiece('down');
            });
            
            mobileRotate.addEventListener('touchstart', (e) => {
                e.preventDefault();
                rotatePiece();
            });
            
            mobileDrop.addEventListener('touchstart', (e) => {
                e.preventDefault();
                hardDrop();
            });
            
            // Add mouse click support for mobile controls (better for testing)
            mobileLeft.addEventListener('click', () => movePiece('left'));
            mobileRight.addEventListener('click', () => movePiece('right'));
            mobileDown.addEventListener('click', () => movePiece('down'));
            mobileRotate.addEventListener('click', () => rotatePiece());
            mobileDrop.addEventListener('click', () => hardDrop());
            
            // Make sure touch events don't cause scrolling
            const touchControls = [mobileLeft, mobileRight, mobileDown, mobileRotate, mobileDrop];
            touchControls.forEach(control => {
                control.addEventListener('touchmove', (e) => e.preventDefault());
                control.addEventListener('touchend', (e) => e.preventDefault());
            });
            
            // Restart button event listener
            restartButton.addEventListener('click', restartGame);
            
            // Handle window resize for responsiveness
            function handleResize() {
                // Adjust for mobile devices
                if (window.innerWidth <= 768) {
                    canvas.width = 240;
                    canvas.height = 400;
                } else {
                    canvas.width = 300;
                    canvas.height = 600;
                }
                
                // Update block sizes
                const blockSize = Math.floor(canvas.width / COLS);
                
                // Redraw the board with the new dimensions
                if (tetrisGameState) {
                    drawBoard();
                    drawNextPiece();
                }
            }
            
            // Listen for window resize events
            window.addEventListener('resize', handleResize);
            
            // Initial call to set the correct sizes
            handleResize();
        });
    </script>
</body>
</html>
